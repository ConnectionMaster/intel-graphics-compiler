; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
;=========================== begin_copyright_notice ============================
;
; Copyright (C) 2024 Intel Corporation
;
; SPDX-License-Identifier: MIT
;
;============================ end_copyright_notice =============================

; RUN: igc_opt %s --opaque-pointers -S -o - -types-legalization-pass | FileCheck %s
; REQUIRES: llvm-14-plus

; should replace phi instruction with alloca store and load instructions

define spir_kernel void @cover.ResolvePhiNode(i1 %cc) {
; CHECK-LABEL: define spir_kernel void @cover.ResolvePhiNode(
; CHECK-SAME: i1 [[CC:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [4 x i32], align 4
; CHECK-NEXT:    br i1 [[CC]], label %[[FIRST:.*]], label %[[SECOND:.*]]
; CHECK:       [[FIRST]]:
; CHECK-NEXT:    [[A:%.*]] = insertvalue [4 x i32] undef, i32 13, 0
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 0
; CHECK-NEXT:    store i32 13, ptr [[TMP1]], align 4
; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 1
; CHECK-NEXT:    store i32 undef, ptr [[TMP2]], align 4
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 2
; CHECK-NEXT:    store i32 undef, ptr [[TMP3]], align 4
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 3
; CHECK-NEXT:    store i32 undef, ptr [[TMP4]], align 4
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[SECOND]]:
; CHECK-NEXT:    [[B:%.*]] = insertvalue [4 x i32] undef, i32 144, 0
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 0
; CHECK-NEXT:    store i32 144, ptr [[TMP5]], align 4
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 1
; CHECK-NEXT:    store i32 undef, ptr [[TMP6]], align 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 2
; CHECK-NEXT:    store i32 undef, ptr [[TMP7]], align 4
; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr [4 x i32], ptr [[TMP0]], i32 0, i32 3
; CHECK-NEXT:    store i32 undef, ptr [[TMP8]], align 4
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[TMP9:%.*]] = load [4 x i32], ptr [[TMP0]], align 4
; CHECK-NEXT:    ret void
;
entry:
  br i1 %cc, label %first, label %second
first:
  %a = insertvalue [4 x i32] undef, i32 13, 0
  br label %exit
second:
  %b = insertvalue [4 x i32] undef, i32 144, 0
  br label %exit
exit:
  %result = phi [4 x i32] [%a, %first], [%b, %second]
  ret void
}
