/*========================== begin_copyright_notice ============================

Copyright (C) 2023 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/

/*========================== begin_copyright_notice ============================

Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
See https://llvm.org/LICENSE.txt for license information.
SPDX-License-Identifier: Apache-2.0 with LLVM-exception

============================= end_copyright_notice ===========================*/

# TODO: Once upstreamed, update with LLORG revision & adjust per community review

From a7317169c80681f9128c22f5f071e206b7617c28 Mon Sep 17 00:00:00 2001
From: Artem Gindinson <artem.gindinson@intel.com>
Date: Wed, 23 Aug 2023 15:49:30 +0200
Subject: [PATCH] [InstCombine] Check for NaN before folding `select` for FP
 operators

---
 llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
index 9f8991f4d..ff52bb9cf 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
@@ -456,8 +456,11 @@ Instruction *InstCombinerImpl::foldSelectIntoOp(SelectInst &SI, Value *TrueVal,

         if (OpToFold) {
           FastMathFlags FMF;
-          if (isa<FPMathOperator>(&SI))
+          if (isa<FPMathOperator>(&SI)) {
             FMF = SI.getFastMathFlags();
+            if (!FMF.noNaNs())
+              return nullptr;
+          }
           Constant *C = ConstantExpr::getBinOpIdentity(
               TVI->getOpcode(), TVI->getType(), true, FMF.noSignedZeros());
           Value *OOp = TVI->getOperand(2-OpToFold);
@@ -493,8 +496,11 @@ Instruction *InstCombinerImpl::foldSelectIntoOp(SelectInst &SI, Value *TrueVal,

         if (OpToFold) {
           FastMathFlags FMF;
-          if (isa<FPMathOperator>(&SI))
+          if (isa<FPMathOperator>(&SI)) {
             FMF = SI.getFastMathFlags();
+            if (!FMF.noNaNs())
+              return nullptr;
+          }
           Constant *C = ConstantExpr::getBinOpIdentity(
               FVI->getOpcode(), FVI->getType(), true, FMF.noSignedZeros());
           Value *OOp = FVI->getOperand(2-OpToFold);
